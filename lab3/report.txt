Samantha Rack
CSE 20212
Lab 3 Report

When the user runs ./main, the driver program, in the part3question3 folder, 3 address labels for Two Day shipping are printed, followed by 3 address labels for the Overnight shipping option.  Each of these labels has the sender's information in the upper left corner and the recipient's information centered.  Below each of the labels is information about the package itself, including its weight, cost per ounce to ship, any additional fees that apply (for Two Day shipping, it is a flat rate additional charge, and for Overnight shipping, it is an additional charge per ounce), and the total cost of the delivery of the package.  After each of the labels is printed to the screen, the total cost to ship all of the packages is displayed.  

The implementation of this program is done through the use of inheritance and polymorphism.  The three classes used in this program- Package, TwoDayPackage, and OvernightPackage- each have an interface with the class definition and prototypes for the member functions, and also have an implementation file to define member functions.  TwoDayPackage and OvernightPackage are derived classes, inheriting from Package class, and receive this inheritance through including : public Package in the class declaration line.  Package class has two virtual functions.  One is pure virtual (printLabel()), and makes the class abstract.  The other virtual function, calculateCost(), is not pure virtual, and therefore is implemented in the Package.cpp file.  This function is used by the derived classes in their own definitions of calculateCost().  Both of the derived classes implement printLabel(), making them concrete, and printLabel(), so that they have unique outputs when that member function is called by a Package pointer.  The main.cpp file instantiates 3 objects of type TwoDayPackage, and 3 of type OvernightPackage.  A static array is created, containing elements of type Package *, which are set to point to the objects of the derived classes.  A for loop is then used to print each of the package labels, calling the same line (packagePointer[i]->printLabel()) and printing the appropriate derived class's information.  The virtual function calculateCost() is used in a similar way to calculate the total cost of sending all of the packages.

The program was verified through running and checking the display as the user, verifying the calculations for prices of the different kinds of packages and for the total price to ship all of the packages, and by building the program incrementally, checking each module as it was created.  Through running the program, the layout of the package label and the test displaying information could be verified.  The calculations for the cost of each package (based on the weight, cost per ounce, and additional charges) was verified by manually entering the data into a calculator.  These calculations also verified the virtual character of the member funciton calculateCost of Package class.  The value returned by packagePointer[i]->calculateCost() matched the value that for the derived classes, not the base class.  Each of the classes was implemented one module at a time, and each of these was debugged before the next one was started.  This ensured that as the program was built, the foundation was correct.  This also decreased the amount of time that was required to find and fix compilation and runtime errors.  

A base class is made abstract by declaring at least one of its member functions as a pure virtual function.  Such a function has the keyword virtual before its return type, and after the parameter list, it has = 0.  For example, the Package class is made abstract by declaring its printLabel() function as pure virtual (virtual void printLabel() = 0 ;).  The function printLabel() is not implemented for the class.  Additionally, objects of type Package cannot be instantiated.  A derived class that inherits from an abstract class is made concrete by providing implementation for any pure virtual functions in its base class.  The member function(s) are still virtual, but the derived class can be instantiated because all of its member functions have an implementation.  For example, the TwoDayPackage derived class inheriting from the Package class has a printLabel function like the pure virtual printLabel function in Package.  It is still declared virtual (virtual void printLabel() ;), but there is no = 0 in the .h file, and there is an implementation defined in the TwoDayPackage.cpp file.  The OvernightPackage class also implements its printLabel() function, and therefore objects of that type can be instantiated.

For the Package class and its derivatives, the inheritance approach is more natural.  As was discussed in class and in the Deitel C++ book, inheritance more natually describes an "is a" relationship.  TwoDayPackage and OvernightPackage are a subset of all types of Packages.  The two derived classes each contain the characteristics found in all objects of type Package.  Inheritance allows the derived classes to become a more specific type of the base class, and this is the relationship that Package and TwoDayPackage/OvernightPackage have.  Composition works well with a "has a" relationship, but this does not easily apply in the situation of Package, TwoDayPackage, and OvernightPackage.  Additionally, when using composition, the . operator has to be used to access the object that is a data member of the other class.  This gives more opportunity for syntax and logic errors in the programs.

Virtual functions are declared in the header file with the keyword virtual before their return type.  A virtual function is redefined in any classes that inherit from the base class with the virtual function.  When a base class pointer points to an object of a derived class to invoke a virtual function, the implementation defined in the derived class is called.  In contrast, a pure virtual function has all the characteristics of a virtual function, but it is not implemented.  Having a pure virtual function in a class also makes the class abstract, which means that no objects of the class may be instantiated.  A pure virtual function should be defined in a class when it does not make sense for an object of that type to be defined.  Virtual functions should be used when the base class may still be instantiated, but when it would be beneficial for a general function (ie. print()) to be redefined in each of the base classes.  This allows for a base class pointer pointing to derived class objects to invoke the derived class member functions.
