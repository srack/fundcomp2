Samantha Rack
CSE 20212
Lab 5 Report

When the user runs the driver program defined by main.cpp in part3 folder, a Sudoku board is displayed to him or her, and he or she is requested to enter a row and column corresponding to the desired location on the board and a value he or she would like to put into that cell.  These values are separated by an ENTER.  After this is entered, the user is prompted with either (1) an error message stating that the row and/or column numbers are outside of the range of the board, the cell is already filled with another value, or the value is invalid for that cell because it has already been put in the row, column, and/or mini grid; or (2) an updated board with his or her chosen value included in the chosen position.  This process continues until the board has been validly completed and the game is over.  Note that because the user cannot change a previous value he or she put in a cell, it is possible that the user cannot win the game, and the program will terminate if the user types -1 when prompted for input.

Internally, this program is made up of a driver program that instantiates a Puzzle object and calls the play() function, and an implementation and interface file that includes the definition of the templated class Puzzle and its member functions(Puzzle.h).  main.cpp simply includes the file Puzzle.h, instantiates a Puzzle object (hardcoded to read the file sudoku.txt - the 9x9 sudoku puzzle), and calls the object's member function play.
The implementation of the templated Puzzle class includes all of the coding for the user's interaction with the Puzzle object.  The interface and implementation are combined in one file for parts 2 and 3 because it is a templated class.  The Puzzle constructor takes a filename as its argument, and then opens the file.  A while loop is used with eof() member function of ifstream class to determine how many items are in the given file.  This number is used to determine if it is a 4x4 or 9x9 puzzle.  Space, newline, and end of file characters are ignored in the count.  Additionally in this while loop, to determine if it is a sudoku or a wordoku, the isdigit() function is called to count the number of digits.  If the number of digits equals the number of items, then in the second read through the file, atoi() function is used to convert these items to integers.  After determining the number of items, nested for loops along with a temporary vector object are used to read in the numbers/chars.  push_back is used with each of the individual ints/chars as well as with the temporary vector to produce the resulting 2D vector grid.
The print() function for Puzzle uses nested for loops to print the private data member grid, which contains the information read from the file.  This function also includes some formatting characters to separate the mini grids and add indices to the columns and rows.
The play() function is called in main.cpp and is used for interacting with the suser.  This is where the user is prompted to enter the requested information, and where this information is received.  The ufnction calls isValidEntry(), a helper function within the Puzzle class that checks if the chosen location and value entered are valid for the given grid.  If isValidEntry() returns true, the user's value is entered in the location specified, and the grid is reprinted.  
When isValidEntry() is called, it verifies that the location entered is within the range of the board (using private data member dimension), that the cell is not already occupied (comparing the grid value to 0 and '0'), and that the entered information does not break the rules of the game.  This final check is broken into the functions checkHorizonal(), checkVertical(), and checkMiniGrid().  Whenever isValidEntry() returns 0, it also prints an error message stating the problem with the user's choice.
checkHorizontal() and checkVertical() perform operations very similarly to check that the value entered for a specified row or column (respectively) is not already found in that row or column.  Both of these functions use a for loop to loop through the specified row or column, and returning 0 if it finds a value that matches the user's entry.  checkMiniGrid() first determines minRow, maxRow, minCol, and maxCol to determine the range of the for loops at the end of the function.  These variables correspond to the range of columns and rows that will be looped through.  The value of row and column entered by the user as well as the dimension is used to determine these variables.  After these are found, nested for loops are used to check if the chosen entry by the user matches any of the entries already in the cell. 
The final function in the Puzzle class is gameOver(), which determines if the Puzzle object has been completely filled in.  This is checked by looking for any zeros in the grid 2D vector.  If none are found, then the Puzzle is complete, and the game has ended.  

This program was verified to be accurate through testing on different Puzzle objects (ie. 4x4 grid, 9x9 grid, and wordoku grid) and verifying that the check functions as well as the play function were working correctly.  Boundary cases such as those along the edge of the puzzle and beyond the edge were also checked.  Different errors were entered to see that the program output the correct message, and continued to request input until a correct location and value was entered.  The puzzles were also completed an checked by sight to ensure that gameOver() worked correctly.  Additionally, the program was written incrementally, with each step being tested and debugged as it was completed.  

The program does not work well when invalid values are entered by the user.  For example, if a number outside the range of 1-9 was entered, there is no verification of the user's entry, and it would be valid because it does not match any of the values in its row, column, or mini grid.  Additionally, the program fails in that if the user makes an incorrect move early on in the puzzle (that is valid at the time he or she enters the value) this move is unable to be corrected by later actions.  This results in puzzles that are unable to be solved after mistakes.  However, when the user enters valid values, the program is robust in checking that the values are in valid locations based on the current location of the grid and the limits of the grid.  The program is also able to validate input for Puzzle of characters, and check if the puzzle is complete.  The implemenation of the Puzzle class and its member function play() involved mostly communication with the user (using cin and cout statements) and verification.  Once information was received from the user, helper functions of the Puzzle class were most important in verifying that the location was in the range, and that the value was valid for the given location based on the rules of Sudoku.  while and for loops were important for reading in information from the files, looping through the grid 2D vector, and interacting with the user until the program received valid input or until the game was over.
