Samantha Rack
CSE 20212
Lab 6

	When the user runs ./main, he or she is prompted to choose a puzzle from 4 file options (easy.txt, medium.txt, cc1.txt, their own defined file).  If the user chooses option 4, he or she is then prompted to enter the path to a text file of a sudoku puzzle that they would like to be solved.  After entering the desired option, the puzzle in the corresponding file is displayed, unsolved to the screen.  The program sleeps for 2 seconds, then the solution is displayed.  The program is able to solve the sudoku puzzles for the first three options provided by the menu.  These are the three examples given for the lab.  However, if the user enters a file with a more difficult sudoku puzzle that cannot be solved by the program, it displays an error message, and then the puzzle as much as it was able to complete.

	Internally, the program is made up of a driver file (main.cpp), an interface for the Puzzle class (Puzzle.h), and an implementation of the Puzzle class's member functions (Puzzle.cpp).  main.cpp first uses cout and cin to request and receive input from the user for which file to use for instantiating the Puzzle object.  If the user chooses option 4, another set of cout and cin commands are used to read in the path to the desired file.  Then, the nondefault (only) constructor for the Puzzle class is used to instantiate an object, which is displayed using overloaded << operator, then solved using the member function solve().
	Puzzle.h defines the interface for the Puzzle class.  This class is not templated (ie. only works for integer puzzles, no wordokus).  The overloaded << operator is declared as a friend function of the Puzzle class, and is defined in the Puzzle.cpp file using the print() member function.  Public member functions include the nondefault constructor, taking a string (filename) as an argument), the print function, and the solve function.  Private members of the class Puzzle include two private data members- a 3D vector to represent the grid and the dimension (ie. 4 for 4x4 puzzle or 9 for 9x9 puzzle)- and helper functions called by the public member functions.  The 3D vector, grid, is used to represent each box in the Puzzle, as well as the possibilities for each of these boxes.  All of the final dimension vectors are of size 9, and are initialized with 1s unless the box has a predefined value (given by the specific puzzle).  0s in any given position of the 3rd dimension vector represent values that that certain box cannot take.  
	Puzzle.cpp contains the implemenation of the member functions of the Puzzle class.  The constructor for the Puzzle class is very similar to the one defined for Lab 5.  The filename taken as an argument is used with ifstream so its data can be read.  First the number of valid characters (ie. not spaces or new lines) is counted to determine the dimension of the sudoku puzzle.  Then, nested for loops are used to read in the information from the file character by character.  A temporary vector of type int uses member function push_back to fill in possible values for each of the grid members.  This temporary vector is then pushed back into another temporary vector of type vector <int>, a two dimensional vector used to store each column, one at a time.  This vector is pushed back into the 3D vector data member grid after each column has been read.  The third dimension vector is initialized to contain all 1s if the character read in is 0, and is initialized to have 8 0s and 1 1 in the location corresponding to the correct value if the character read in is not a zero.
	The print() function is used to print the puzzle in its current state.  It calls the function valueDetermined() to determine what to print for each location in the grid.  Nested for loops set up in a similar way as print() from lab 5 are used to print the Puzzle object as a formatted Sudoku game.  The valueDetermined() function is a helper function used in many of the other member functions of Puzzle.  This function returns 0 if the value of the location in the puzzle has not yet been determined, or the value if it has been determined.  This is determined by a for loop that counts the number of ones in the third dimension of the vector grid.  If only one 1 exists, then the value has been determined, and the location of this 1 plus one equals the correct value (+1 to take care of indexing beginning at 0 instead of 1).  If more than one 1 is found, then the value has not yet been determined, and 0 is returned.  The helper function gameOver(), used as the condition for the while loop in solve(), traverses the grid using nested for loops and the valueDetermined() function to find if all of the grid has been filled in, in which case it would return 1.  Otherwise 0 is returned to indicate that there are still undetermined values on the board.
	The solve() member function was implemented using a while loop with the condition of !gameOver().  Within the while loop, the search/elimination algorithm and the singleton algorithm were implemented within nested for loops for all locations in the puzzle and all values at the locations.  If a certain location had already been solved for, contiue was used to skip this element and go to the next one in the iteration.  The both algorithms first check if the certain value at the unsolved location is still a possibility (ie. grid[row][column][value] == 1).  If it is not 1, continue is used to skip this element.  Otherwise, functions are called to determine the next action.  For the search/elimination algorithm, the function isEliminated() is called.  This function is a series of unnested if statements calling functions checkHorizontal(), checkVertical(), and checkMiniGrid().  Each of these functions iterates through the row, column, or mini grid in which the location is found to see if another location has a valueDetermined() that matches the one being tested.  If it does, isEliminated() returns 1 to solve(), and this particular element of the 3D vector (grid[row][column][value]) is set to 0.  It is no longer a possibility.  The singleton algorithm checks for singleton using the function isSingleton(), which also uses unnested if statements calling checkHorizontalUnknowns(), checkVerticalUnknowns(), and checkMiniGridUnkowns().  These functions determine if any other unsolved for locations in the respective row, column, or mini grid as the currrent box has the possibility of a particular value.  If none of them do, then this value must be the correct value at the location.  In this case, isSingleton() returns 1, and the remaining 1s in the given location's third dimension vector are set to zeros (indicating that the value is the solution value for that location).  Each time through the main while loop of solve(), the grid has been updated, so all locations are checked and updated.  There is a check, however, for puzzles that are not able to be solved by the program.  The variable change is set to 0 at the top of each while loop, and is incremented each time a singleton is found or a possibility is eliminated from a certain location.  If the variable change equals zero at the end of an iteration through the solve() function's while loop, then the program can not do anything to solve the puzzle.  An error message is printed with cout, the current state of the puzzle is printed, and the program exits with a return status of 1.

	The program was tested for validity using multiple methods.  The final program was tested using easy.txt, medium.txt, and cc1.txt.  Each of these puzzles was used as the input file to be solved, and the final puzzle was output to the screen.  The solutions for easy.txt and medium.txt matched the solutions provided on Piazza, so the program was able to successfully solve these without any problems.  The solution to the puzzle in cc1.txt was verified by comparing the output of the program to the output of an online Sudoku solver.  The outputs matched, so the final program was robust enough to solve at least one of the extra credit problems.  The program was also written incrementally to allow for testing of particular functions as they were built.  After the constructor was written, a simple debugPrint() function was written to test that the values were inserted in the 3D vector correctly when they were read from the file.  debugPrint() printed out each box's vector of possibilities.  The values already determined for the puzzle were checked to have only one 1 and to have this 1 in the correct position.  The print() function was built next, and debugged by comparing the output to the original file.  solve() was modularized to reduce the complexity of the function.  First, only the search/elimination algorithm was implemented, and then tested.  When a puzzle was unable to be solved, the extent to which it was solved was printed to the screen, and all undetermined boxes were checked to ensure that they in fact could not be solved with that algorithm.  Finally, the singleton algorithm was implemented, with horizontal singletons being found and tested first.  

	Each of the provided .txt files for Puzzle input worked well with the program written.  However, when other difficult puzzles were obtained from the internet for additional testing, the program was unable to provide the solution.  These puzzles required algorithms that went beyond the singleton and search/elimination methods implemented in the program.  So while the program is relatively robust for the purpose of the class, it does not cover all methods that may be required when solving a sudoku.  Extensive detail on the implementation can be found above with the explanation of how the program works internally.  Overall, many nested loops were necessary to traverse the 3D vector and perform necessary operations on the locations and their possiblities.
